"""Two classes (peptide and mass_spectrum) can be used to study peptides or amino acids."""

from bio_table import AMINO_BASES, AMINO_MASS, PROTEINOGENIC_MASS
from collections import Counter

class peptide:
    """Peptide class. Default value: LEQN, No label"""

    def __init__(self, pep="LEQN", label='No label'):
        """Peptide initialization, validation."""
        self.pep = pep.upper()
        self.label = label
        self.is_valid = self.__validate()
        assert self.is_valid, f"Provided sequence may not be a correct peptide."

    def __repr__(self):
        return f"[Type]: Peptide\n[Sequence]: {self.pep}\n[Length]: {len(self.pep)}\n[Label]: {self.label}"

    def __validate(self):
        """Check the sequence to make sure it is a valid peptide"""
        return set(AMINO_BASES).issuperset(self.pep)

    # Peptide functions:

    def mass(self):
        """
        Calculates the integer mass of the peptide.

        Returns
        ----------
        int: Integer mass 
        """
        return amino_mass(self.pep)

    def cyclospectrum(self):
        """
        Generates the theoretical spectrum of a cyclic peptide.

        Returns
        ----------
        list: Cyclospectrum, i.e. a collection of all of the masses of its subpeptides
        """
        return pep_cyclic_spectrum(self.pep)

    def score(self,experimental):
        """
        Counts the number of masses shared between Cyclospectrum(peptide) and a given spectrum.

        Parameters:
        ----------
        spectrum (list): An experimental spectrum

        Returns
        ----------
        int: The score of peptide against spectrum
        """ 
        self_spectrum = pep_cyclic_spectrum(self.pep)
        score = 0    
        for i in experimental:
            if i in self_spectrum:
                score +=1 
                self_spectrum.remove(i)
        return score
    

class mass_spectrum:
    """Experimental spectrum class (generated by mass spectrometer). Default value: [0, 113, 128, 186, 241, 299, 314, 427], No label"""

    def __init__(self, spectrum=[0, 113, 128, 186, 241, 299, 314, 427], label='No label'):
        """Spectrum initialization, validation."""
        self.spectrum = spectrum
        self.label = label
        self.is_valid = self.__validate()
        assert self.is_valid, f"Provided sequence may not be a correct spectrum."

    def __repr__(self):
        return f"[Type]: Spectrum\n[Mass]: {self.spectrum}\n[Length]: {len(self.spectrum)}\n[Label]: {self.label}"

    def __validate(self):
        """Check the sequence to make sure it is a valid spectrum"""
        return all(isinstance(x, int) for x in self.spectrum)

    # Mass spectrum functions:
    def cyclopeptide_sequencing(self):
        """
        Finds peptides that are most consistent with the spectrum. Given an experimental spectrum, it will form a collection Peptides of candidate linear 
        peptides initially consisting of the empty peptide, which is just an empty string (denoted "") having mass 0. At the next step, it will expand Peptides 
        to contain all linear peptides of length 1. It continues this process, creating 18 new peptides of length k + 1 for each amino acid string Peptide of 
        length k in Peptides by appending every possible amino acid mass to the end of Peptide. Every time it expands Peptides, it trim the candidates by keeping 
        only those linear peptides that remain consistent with the experimental spectrum.

        Returns
        ----------
        list: All the peptides that are most consistent with the spectrum.
        """
        parent_mass = max(self.spectrum)
        candidate = ['']
        final = []
        while len(candidate) > 0:
            candidate = expand_peptide(candidate)
            for pep in candidate[:]:
                if sum(pep) == parent_mass:
                    if (cyclic_spectrum(pep) == self.spectrum) and (pep not in final):
                        final.append(pep)
                    candidate.remove(pep)
                elif set(self.spectrum).issuperset(pep) == False:
                    candidate.remove(pep)
                elif set(self.spectrum).issuperset(linear_spectrum(pep)) == False:
                    candidate.remove(pep)
                elif sum(pep) > parent_mass:
                    candidate.remove(pep)
        return final

    def leaderboard_cyclopeptide_sequencing(self, n):
        """
        Finds peptides that are most consistent with the spectrum with a Leaderboard during peptide search. It adapts the cyclopeptide_sequencing algorithm 
        to find a peptide with maximum score. At each step, it expands all candidate peptides found in Leaderboard, then eliminates those peptides whose 
        newly calculated scores are not high enough to keep them on the Leaderboard.

        Parameters:
        ----------
        n (int): The number of highest scoring candidate peptides that are stored in the Leaderboard

        Returns
        ----------
        list: The peptide that is most consistent with the spectrum
        int: The score of the best peptide against spectrum
        """
        parent_mass = max(self.spectrum)
        leaderboard = [['',0]]
        leader_peptide = ['',0]
        while len(leaderboard) > 0:
            leaderboard = expand_peptide_score(leaderboard,self.spectrum)
            for pep in leaderboard[:]:
                if sum(pep[0]) == parent_mass:
                    if pep[1] > leader_peptide[1]:
                        leader_peptide = pep
                elif sum(pep[0]) > parent_mass:
                    leaderboard.remove(pep)
            leaderboard = trim_board(leaderboard,n)
        return leader_peptide


    def convo_cyclopeptide_sequencing(self,M,n):
        """
        Finds peptides that are most consistent with the spectrum using spectral convolution. Given an experimental spectrum, it first 
        computes the convolution of an experimental spectrum. It then selects the M most frequent elements between 57 and 200 in the convolution 
        to form an extended alphabet of candidate amino acid masses. It includes the top M elements of the convolution "with ties". Finally, it runs 
        the algorithm leaderboard_cyclopeptide_sequencing, where the amino acid masses are restricted to this alphabet.

        Parameters:
        ----------
        M (int): The number of most frequent elements to keep in an extended alphabet
        n (int): The number of highest scoring candidate peptides that are stored in the Leaderboard

        Returns
        ----------
        list: The peptide that is most consistent with the spectrum
        int: The score of the best peptide against spectrum
        """
        parent_mass = max(self.spectrum)
        leaderboard = [['',0]]
        leader_peptide = ['',0]
        mass_alphabet = convolution_spectrum(self.spectrum,M)
        while len(leaderboard) > 0:
            leaderboard = expand_peptide_score(leaderboard,self.spectrum,mass_alphabet)
            for pep in leaderboard[:]:
                if sum(pep[0]) == parent_mass:
                    if pep[1] > leader_peptide[1]:
                        leader_peptide = pep
                elif sum(pep[0]) > parent_mass:
                    leaderboard.remove(pep)
            leaderboard = trim_board(leaderboard,n)
        return leader_peptide


# Other functions

def amino_mass(peptide):
    # Calculates the integer mass
    mass = 0
    for i in peptide:
        mass += AMINO_MASS[i]
    return mass

def pep_cyclic_spectrum(peptide):
    # Generates the theoretical spectrum of a cyclic peptide with the pattern provided
    pep_len = len(peptide)
    ami_mass = [0, amino_mass(peptide)]
    cyclic = peptide+peptide
    for i in range(pep_len):
        for w in range(1,pep_len):
            ami_mass.append(amino_mass(cyclic[i:i+w]))  
    ami_mass.sort()
    return ami_mass

def linear_spectrum(spectrum):
    # Generates a linear spectrum of a peptide with a list of masses provided
    spec_len = len(spectrum)
    ami_mass = [0, sum(spectrum)]
    for i in range(spec_len):
        for w in range(1,spec_len):
            ami_mass.append(sum(spectrum[i:i+w]))  
    ami_mass.sort()
    return ami_mass

def cyclic_spectrum(spectrum):
    # Generates a cyclospectrum of a peptide with a list of masses provided
    spec_len = len(spectrum)
    ami_mass = [0, sum(spectrum)]
    cyclic = spectrum+spectrum
    for i in range(spec_len):
        for w in range(1,spec_len):
            ami_mass.append(sum(cyclic[i:i+w]))  
    ami_mass.sort()
    return ami_mass

def expand_peptide(peptide):
    # Extend each candidate peptide of length k into 18 peptides of length k + 1
    final = []
    for i in peptide:
        for w in PROTEINOGENIC_MASS:
            final.append([*i,w])
    return final

def expand_peptide_score(peptide,spectrum,mass=PROTEINOGENIC_MASS):
    # Extend each candidate peptide of length k into 18 (or specific number based on a given alphabet) peptides of length k + 1 with score calculated.
    final = []
    for i in peptide:
        for w in mass:
            final.append([[*i[0],w],cyclicscore([*i[0],w],spectrum.copy())])                  
    return final

def trim_board(leaderboard,n):
    # Keep n highest score items in the leaderboard
    leaderboard.sort(key=lambda pep: pep[1],reverse=True)
    if len(leaderboard) == 0:
        return leaderboard
    elif len(leaderboard) < n:
        score = leaderboard[-1][1]
    else:
        score = leaderboard[n-1][1]      
    leaderboard = [pep for pep in leaderboard if pep[1] >=score]
    return leaderboard 

def cyclicscore(experimental,theoretical):
    # Calculates the number of masses shared between Cyclospectrum(experimental) and the theoretical spectrum.
    experimental = cyclic_spectrum(experimental)  
    score = 0    
    for i in experimental:
        if i in theoretical:
            score +=1 
            theoretical.remove(i)
    return score

def convolution_spectrum(peptide,m):
    # Generates a spectral convolution for a given spectrum
    diff = [i-j for i in peptide for j in peptide if i > j]
    amino = [w for w in diff if w >= 57 and w <= 200]
    amino_dict = Counter(amino)
    min_threshold = amino_dict.most_common(m)[-1][1]
    mass = [x for x, count in amino_dict.items() if count >= min_threshold]
    mass.sort()
    return mass